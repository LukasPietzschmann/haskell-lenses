\makeatletter
\providecommand*{\input@path}{}
\edef\input@path{{../libs/smile},\input@path}
\makeatother

\documentclass{exercise}

\usepackage{fontspec}
\usepackage[sfdefault]{FiraSans}
\setmonofont[
	Path = ./fonts/,
	Scale = .9,
	Extension = .ttf,
	Contextuals=Alternate,
	BoldFont={*-Bold},
	UprightFont={*-Regular},
]{Fira Code}

\newcommand\h[2][]{\lstinline[language=haskell,#1]{#2}}
\lstnewenvironment{haskell}{\lstset{language=haskell}}{}

\def\link #1 to #2;{\def\ULdepth{.5pt}\def\ULthickness{.1pt}\uline{\href{#2}{#1}}}

\title{Functional Programming II}
\author{Lukas Pietzschmann}
\email{lukas.pietzschmann@uni-ulm.de}
\topic{Lenses}
\institute{Institute of Software Engineering and Programming Languages}
\sheet{4}
\date{May~17\textsuperscript{th}, 2024}

\begin{document}
	\maketitle

	\begin{exercise}[Some Hints]{}
		If you ever get stuck, don't even think about asking me for help! While that was
		obviously a joke, I'll leave you some notes on the documentation here, just in
		case you want to try helping yourself first.

		You can find the lens package's documentation \link here to
		https://hackage.haskell.org/package/lens;. If you scroll down to \link Modules
		to https://hackage.haskell.org/package/lens\#modules;, you can find an overview
		of all the modules that are part of the lens package. Here's a little summary of
		the most important ones:
		\begin{description}
			\item[Control.Lens.Lens] Here you can find the \texttt{Lens} type itself and
				some functions to work with it. We won't need most of them, but you can,
				e.g., find the \link\texttt{\&}-operators to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Lens.html\#g:4;
				and the \link \texttt{lens} function to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Lens.html\#v:lens;
				here.
			\item[Control.Lens.Operators] Here are all the operators we used. Since this
				module is only a listing of operators from other modules, you can find
				hyperlinks to the actual modules on the left or above every section. You
				can press \texttt{<CTRL-f>} on this page, hit random symbols on your
				keyboard, and you'll probably find an operator with this name.
			\item[Control.Lens.Getter] You probably expected \link\texttt{to} to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Getter.html\#v:to;
				and \link\texttt{like} to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Getter.html\#v:like;
				to be defined here, but you'll also find the \link\texttt{view} to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Getter.html\#v:view;
				function and it's corresponding \link operator to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Getter.html\#v:-94-.;
				there.
			\item[Control.Lens.Setter] Analogous to the \texttt{Getter} module, you can
				find the \link\texttt{set} to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Setter.html\#v:set;
				and \link\texttt{setting} to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Setter.html\#v:setting;
				functions here. Along with, e.g., \link\texttt{over} to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Setter.html\#v:over;
				and some \texttt{set}-like operators.
			\item[Control.Lens.Prism] Here, all Prism related types and functions are
				defined. You might be primarily interested in the section \link Common
				Prisms to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Prism.html\#g:4;.
			\item[Control.Lens.Traversal] Basically, we only used two functions from
				here; \link\texttt{traverse} to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Traversal.html\#v:traverse;,
				and \link\texttt{over} to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Traversal.html\#v:over;.
				But the \link Common Traversals to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Traversal.html\#g:5;
				section might contain some more interesting functions.
		\end{description}
		If you are looking for a specific function, you can also always use the Quick
		Jump button on top of the page. There, you can just type the name of the
		function and the search box will present you a link to its documentation.
	\end{exercise}

	\begin{exercise}[Exercise 0]{Setup}
		To get started, you should have the lens package installed. You can use cabal for this:
		\begin{lstlisting}[language=bash]
			cabal install --lib lens
		\end{lstlisting}
		On my system, I have GHC \texttt{9.4.8} and lens \texttt{5.2.3} installed.

		You can check if your installation works by loading the provided
		\texttt{Main.hs} file into GHCi and printing the value of
		\texttt{currentTextWidth}.
		\begin{haskell}
			ghci Main.hs
			ghci> test
			((1,2),3,4)
		\end{haskell}
		If this works, you should be good to go.
	\end{exercise}

	\begin{exercise}{Getting familiar with lenses again}
		Let's start easy by composing some lenses and accessing and changing some
		values.
		\begin{tasks}
			\item Combine different lenses to form a new lens that focuses on the string
				\h{"Hi"} inside \h{(1, ("Hi", "Ho"), 2)}.
			\item Now use this lens to retrieve the focused part. Use both the operator
				and function for this.
			\item Change \h{"Hi"} to a integer value of your choice and bind the result
				to a name. Again, using the operator and function.
			\item Finally, use the lens --- that now focuses on the integer value you
				just set --- to multiply the value by \h{11}.
			\item Now we change things up a little bit. \h{"Hi"} is now inside a list:
				\h{(["Hi", "Ho"], ["He", "Hu"])}. Change your lens accordingly.
			\item Can you think of another lens that can focus on \h{"Hi"}?
			\item Finally, we no longer want to focus on just one element, but on
				\h{"Hi"} and \h{"He"}. Write a lens that does exactly this.
			\item Now use this lens to change both \h{"Hi"} and \h{"He"} to a string of
				your choice.
		\end{tasks}
	\end{exercise}

	\begin{exercise}{We need to go deeper}
		Now that you feel comfortable with lenses, let's go a little further. In this
		exercise, we will be working with a file system. I have prepared some ADTs, go
		take a look at them~\ldots~Alright, let's get started.
		\begin{tasks}
			\item We will start simple by creating a lens for each element of the
				\h{Metadata} ADT. Hint: for now, you can use the \h{lens} function. You
				can try it without this helper later.
		\end{tasks}
		In the following, we will use this as an example:
		\begin{haskell}
example :: FileSystem
example = FileSystem $ Folder "root" [
    Folder "home" [
        Folder "luke" [
            File $ Doc Text (Metadata ".zshenv" "luke") "export EDITOR=nvim",
            File $ Doc Text (Metadata ".zsh_history" "luke") "sudo dnf rm java"
          ]
      ]
  ]
		\end{haskell}
		\begin{tasks}[resume*]
			\item Without evaluating it, try to determine what the expression \h{example ^.
				_File . metadata} would evaluate to?
			\item If you have not figured the previous task out: it does not evaluate to
				anything, as there's a type error. Implement a fix for it, without
				changing the expression.
			\item How can we change the above expression to fix the error, while not
				changing what the lens focuses on?
		\end{tasks}
		Aren't lenses, prisms, and traversals nice? But for the remaining tasks of this
		exercise, we need a new thing~\ldots~folds! But don't worry, I will gently introduce you to
		them.

		Imagine, you want to modify the contents of a specific file, but you don't know
		it's index and exact path. The only thing you know is its name. After the
		following tasks, you will have written a function, that takes a file name and
		focuses on that exact file.
		\begin{tasks}[resume*]
			\item To get into the right mood, forget lenses for a moment. Let's start by
				writing a plain old Haskell function \h{searchFile :: String -> [Document]
				-> [Document]} using \h{filter}. For now, we assume that any input to
				this function is a list with one layer of documents:
				\begin{haskell}
example = [
  Doc Text (Metadata ".zshenv" "luke") "export EDITOR=nvim",
  Doc Text (Metadata ".zsh_history" "luke") "sudo dnf rm java"
]
				\end{haskell}
		\end{tasks}
		Now, we need a way to handle arbitrary nesting depths. We can tackle this by
		flattening everything into a single list of files. Luckily this is pretty easy.
		You already know that \h{^..} gives us a list-view of all targets of a
		traversable, but this operator also works on \h{Fold}s!
		\begin{tasks}[resume*]
			\item Implement an instance of \h{Foldable} for \h{File} that folds over all
				documents in the file hierarchy, no matter the depth.
		\end{tasks}
		Awesome! Now we can use the \link\h{folded} to
		https://hackage.haskell.org/package/lens-5.3.1/docs/Control-Lens-Combinators.html\#v:folded;
		function to build a \h{Fold} from our \h{Foldable} and use \h{^..} to view a
		flat list of all targets of the fold!
		\begin{haskell}
			example ^.. folded
		\end{haskell}
		As a last step, we now need a way to filter this list list. And we'll do it in
		the lens-way.
		\begin{tasks}[resume*]
			\item Look through \link Control.Lens.Fold to https://hackage.haskell.org/package/lens-5.3.1/docs/Control-Lens-Fold.html;
				and search for a function that can be composed with a \h{Fold} and be
				used for filtering.
			\item Now use this function like the \h{filter} from task \emph{e)}, so we
				can use our \h{find} function like this:
				\begin{haskell}
example ^.. folded . find ".zshenv" . content
-- ["export EDITOR=nvim"]
				\end{haskell}
		\end{tasks}
		By the way, if we are sure that there will be at maximum a single file with this
		name, we can also use \h{^?} to get a \h{Maybe} instead of a list.
		\begin{haskell}
example ^? folded . find ".zshenv" . metadata . author
-- Just "Luke"
		\end{haskell}
		\begin{tasks}[resume*]
		\item With this new superpower unlocked, write \h{filesFromAuthor} in the same
			way to focus on all files from a specific author.
			\begin{haskell}
example ^.. folded . filesFromAuthor "Luke" . metadata . title
-- [".zshenv",".zsh_history"]
			\end{haskell}
		\item Last but not least, implement \h{filesWithAuthor} to search for files with
			a specific author and name.
			\begin{haskell}
example ^?! folded . filesWithAuthor ".zshenv" "Luke" . metadata . title
-- ".zshenv"
			\end{haskell}
		\end{tasks}
	\end{exercise}

	\begin{exercise}{Respekt, wer's selber macht}
		In this exercise we want to reimplement some common library function to get a
		better understanding of how they work.

		You might remember our exploration of the \h{Lens} type from the lecture. Here's
		a little refresher:
		\begin{haskell}
			type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
		\end{haskell}
		Depending on the operation performed on the lens, Haskell can select a fitting
		functor automagically. The functor then carries out the operation.
		\begin{tasks}
		\item The operator \h{.~} uses the \h{Identity} functor, so it requires a lens
			of type \h{(a -> Identity b) -> s -> Identity t}. Knowing this, implement
			your own version of the operator, so it has the following type signature:
			\begin{haskell}
				(.~.) :: ((a -> Identity b) -> s -> Indentity t) -> b -> s -> t
			\end{haskell}
			It kinda looks like a person with a mustache, but upside down
			\raisebox{1.2ex}{\rotatebox{180}{\emoji{disguised-face}}}. Your
			implementation should behave identically to the operator from the lens
			package.

			If you're a bit rusty on how \h{Identity} works and how you get things out
			of it, check out its \link documentation to
			https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Functor-Identity.html\#t:Identity;.
		\item Next, implement \h{\%~}. This operator behaves like \h{over}:
			\begin{haskell}
				(a,b,c) & _3 %~ f
				-- (a,b,f c)
			\end{haskell}
			Your implementation should, again, behave like the predefined operator, and have the following
			type signature:
			\begin{haskell}
				(%~.) :: ((a -> Identity b) -> s -> Identity t) -> (a -> b) -> s -> t
			\end{haskell}
		\item The last set-like operator we want to implement is \h{*~}. It multiplies the lense's target
			by a given value:
			\begin{haskell}
				(1,2) & _1 *~ 4
				-- (4,2)
			\end{haskell}
			You know the dill, here's the typesignature:
			\begin{haskell}
				(*~.) :: Num a => ((a -> Identity a) -> s -> Identity t) -> a -> s -> t
			\end{haskell}
		\end{tasks}
		Set-like function are only one side of the coin. In the next task, we want to
		reimplement \h{view}, or more precisely, the \h{^.} operator. Insead of the
		\h{Identity} functor, it uses \h{Const}. Again, here's a link to its \link
		documentation to
		https://hackage.haskell.org/package/base-4.19.1.0/docs/Control-Applicative.html\#t:Const;,
		so you can familiarize yourself with it. Operators using \h{Const}, take lenses
		looking like this: \h{(a -> Const a b) -> s -> Const a t}.
		\begin{tasks}[resume*]
			\item Implement the view operator \h{^.} respecting the following type signature:
				\begin{haskell}
					(.^.) :: s -> ((a -> Const a b) -> s -> Const a t) -> a
				\end{haskell}
		\end{tasks}

	\end{exercise}
\end{document}