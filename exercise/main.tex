\makeatletter
\providecommand*{\input@path}{}
\edef\input@path{{../libs/smile},\input@path}
\makeatother

\documentclass{exercise}

\usepackage{fontspec}
\usepackage[sfdefault]{FiraSans}
\setmonofont[
	Path = ./fonts/,
	Scale = .9,
	Extension = .ttf,
	Contextuals=Alternate,
	BoldFont={*-Bold},
	UprightFont={*-Regular},
]{Fira Code}

\newcommand\h[2][]{\lstinline[language=haskell,#1]{#2}}
\lstnewenvironment{haskell}{\lstset{language=haskell}}{}

\def\link #1 to #2;{\def\ULdepth{.5pt}\def\ULthickness{.1pt}\uline{\href{#2}{#1}}}

\title{Functional Programming II}
\author{Lukas Pietzschmann}
\email{lukas.pietzschmann@uni-ulm.de}
\topic{Lenses}
\institute{Institute of Software Engineering and Programming Languages}
\uni{Ulm University}
\sheet{4}
\date{May~17\textsuperscript{th}, 2024}

\begin{document}
	\maketitle

	\begin{exercise}[Some Hints]{}
		If you ever get stuck, don't even think about asking me for help! While that was
		obviously a joke, I'll leave you some notes on the documentation here, just in
		case you want to try helping yourself first.

		You can find the lens package's documentation \link here to
		https://hackage.haskell.org/package/lens;. If you scroll down to \link Modules
		to https://hackage.haskell.org/package/lens\#modules;, you can find an overview
		of all the modules that are part of the lens package. Here's a little summary of
		the most important ones:
		\begin{description}
			\item[Control.Lens.Lens] Here you can find the \texttt{Lens} type itself and
				some functions to work with it. We won't need most of them, but you can,
				e.g., find the \link\texttt{\&}-operators to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Lens.html\#g:4;
				and the \link \texttt{lens} function to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Lens.html\#v:lens;
				here.
			\item[Control.Lens.Operators] Here are all the operators we used. Since this
				module is only a listing of operators from other modules, you can find
				hyperlinks to the actual modules on the left or above every section. You
				can press \texttt{<CTRL-f>} on this page, hit random symbols on your
				keyboard, and you'll probably find an operator with this name.
			\item[Control.Lens.Getter] You probably expected \link\texttt{to} to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Getter.html\#v:to;
				and \link\texttt{like} to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Getter.html\#v:like;
				to be defined here, but you'll also find the \link\texttt{view} to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Getter.html\#v:view;
				function and it's corresponding \link operator to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Getter.html\#v:-94-.;
				there.
			\item[Control.Lens.Setter] Analogous to the \texttt{Getter} module, you can
				find the \link\texttt{set} to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Setter.html\#v:set;
				and \link\texttt{setting} to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Setter.html\#v:setting;
				functions here. Along with, e.g., \link\texttt{over} to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Setter.html\#v:over;
				and some \texttt{set}-like operators.
			\item[Control.Lens.Prism] Here, all Prism related types and functions are
				defined. You might be primarily interested in the section \link Common
				Prisms to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Prism.html\#g:4;.
			\item[Control.Lens.Traversal] Basically, we only used two functions from
				here; \link\texttt{traverse} to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Traversal.html\#v:traverse;,
				and \link\texttt{over} to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Traversal.html\#v:over;.
				But the \link Common Traversals to
				https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Traversal.html\#g:5;
				section might contain some more interesting functions.
		\end{description}
		If you are looking for a specific function, you can also always use the Quick
		Jump button on top of the page. There, you can just type the name of the
		function and the search box will present you a link to its documentation.
	\end{exercise}

	\begin{exercise}[Exercise 0]{Setup}
		To get started, you should have the lens package installed. You can use cabal for this:
		\begin{lstlisting}[language=bash]
			cabal install --lib lens
		\end{lstlisting}
		On my system, I have GHC \texttt{9.4.8} and lens \texttt{5.2.3} installed.

		You can check if your installation works by loading the provided
		\texttt{Main.hs} file into GHCi and printing the value of
		\texttt{currentTextWidth}.
		\begin{haskell}
			ghci Main.hs
			ghci> test
			((1,2),3,4)
		\end{haskell}
		If this works, you should be good to go.
	\end{exercise}

	\begin{exercise}{Getting familiar with lenses again}
		Let's start easy by composing some lenses and accessing and changing some
		values.
		\begin{tasks}
			\item Combine different lenses to form a new lens that focuses on the string
				\h{"Hi"} inside \h{(1, ("Hi", "Ho"), 2)}.
			\item Now use this lens to retrieve the focused part. Use both the operator
				and function for this.
			\item Change \h{"Hi"} to a integer value of your choice and bind the result
				to a name. Again, using the operator and function.
			\item Finally, use the lens --- that now focuses on the integer value you
				just set --- to multiply the value by \h{11}.
			\item Now we change things up a little bit. \h{"Hi"} is now inside a list:
				\h{(["Hi", "Ho"], ["He", "Hu"])}. Change your lens accordingly.
			\item Can you think of another lens that can focus on \h{"Hi"}?
			\item Finally, we no longer want to focus on just one element, but on
				\h{"Hi"} and \h{"He"}. Write a lens that does exactly this.
			\item Now use this lens to change both \h{"Hi"} and \h{"He"} to a string of
				your choice.
		\end{tasks}
	\end{exercise}

	\begin{exercise}{We need to go deeper}
		Now that you feel comfortable with lenses, let's go a little further. In this
		exercise, we will be working with a file system. I have prepared some ADTs, go
		take a look at them~\ldots~Alright, let's get started.
		\begin{tasks}
			\item We will start simple by creating a lens for each element of the
				\h{Metadata} ADT. Hint: for now, you can use the \h{lens} function. You
				can try it without this helper later.
		\end{tasks}
		In the following, we will use this as an example:
		\begin{haskell}
example :: FileSystem
example = FileSystem $ Folder "root" [
    Folder "home" [
        Folder "luke" [
            File $ Doc Text (Metadata ".zshenv" "luke") "export EDITOR=nvim",
            File $ Doc Text (Metadata ".zsh_history" "luke") "sudo dnf rm java"
          ]
      ]
  ]
		\end{haskell}
		\begin{tasks}[resume*]
			\item Without evaluating it, try to determine what the expression \h{example ^.
				_File . metadata} would evaluate to?
			\item If you have not figured the previous task out: it does not evaluate to
				anything, as there's a type error. Implement a fix for it, without
				changing the expression.
			\item How can we change the above expression to fix the error, while not
				changing what the lens focuses on?
		\end{tasks}
		Aren't lenses, prisms, and traversals nice? But for the remaining tasks of this
		exercise, we need a new thing~\ldots~folds! But don't worry, I will gently introduce you to
		them.

		Imagine, you want to modify the contents of a specific file, but you don't know
		it's index and exact path. The only thing you know is its name.\footnote{While
		this is obviously not true in practice, we will assume that file names are
		unique in our filesystem.} After the following tasks, you (hopefully) will have
		written a function, that takes a file name and focuses on that exact file.
		\begin{tasks}[resume*]
			\item To get into the right mood, forget lenses for a moment. Let's start by
				writing a plain old Haskell function \h{searchFile :: String -> [Document]
				-> Maybe Document} using \h{filter}. For now, we assume that any input to
				this function is a list with one layer of documents:
				\begin{haskell}
example = [
  Doc Text (Metadata ".zshenv" "luke") "export EDITOR=nvim",
  Doc Text (Metadata ".zsh_history" "luke") "sudo dnf rm java"
]
				\end{haskell}
		\end{tasks}
		Now, we need a way to handle arbitrary nesting depths. We can tackle this by
		flattening everything into a single list of files. Luckily this is pretty easy.
		You already know that \h{^..} gives us a list-view of all targets of a
		traversable, but this operator also works on \h{Fold}s!
		\begin{tasks}[resume*]
			\item Implement an instance of \h{Foldable} for \h{File} that folds over all
				documents in the file hierarchy no matter the depth.
		\end{tasks}
		Awesome! Now we can use the \link\h{folded} to
		https://hackage.haskell.org/package/lens-5.3.1/docs/Control-Lens-Combinators.html\#v:folded;
		function to build a \h{Fold} from our \h{Foldable} and use \h{^..} to view a
		flat list of all targets of the fold!
		\begin{haskell}
			example ^.. folded
		\end{haskell}
		As a last step, we now need a way to filter this list list. And we'll do it in
		the lens-way.
		\begin{tasks}[resume*]
			\item Look through \link Control.Lens.Fold to https://hackage.haskell.org/package/lens-5.3.1/docs/Control-Lens-Fold.html;
				and search for a function that can be composed with a \h{Fold} and be
				used for filtering.
			\item Now use this function like the \h{filter} from task \emph{e)} and
				compose it with \h{folded} to implement \h{find :: String -> --
				complicated return type}.
		\end{tasks}
		Great, we can now write code like this:
		\begin{haskell}
example ^.. find ".zshenv" . content
-- ["export EDITOR=nvim"]
		\end{haskell}
		By the way, this would also work if our filesystem would contain multiple files
		with the same name. But since we assumed that this is not the case, we can also
		use \h{^?} to get a single \h{Maybe} instead of a list.
		\begin{haskell}
example ^? find ".zshenv" . metadata . author
-- Just "Luke"
		\end{haskell}
	\end{exercise}
\end{document}