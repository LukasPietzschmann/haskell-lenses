\documentclass[aspectratio=169,handout]{beamer}

\makeatletter
\appto\input@path{{../libs/awesome-beamer}, {../libs/smile}}
\makeatother

\definecolor{dred}{HTML}{501613}
\usetheme[english, color, coloraccent=dred, secslide, listings, footnote]{awesome}

\lstdefinelanguage{ts}{
	keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
	ndkeywords={get, number, class, export, boolean, throw, implements, import, this},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	morestring=[b]',
	morestring=[b]"
}

\usepackage[
	backend=biber,
	style=alphabetic
]{biblatex}
\usepackage[strict,autostyle]{csquotes}
\nocite{*}
\addbibresource{refs.bib}

\usepackage{fontawesome5}
\def\ergo{\raisebox{.5pt}{\scalebox{.8}{\faCaretRight}}}

\usepackage{contour}

\usepackage{fontspec}
\setsansfont[
	Ligatures=TeX,
	BoldFont={* Medium},
]{Fira Sans}
\setmonofont[
	Path = ./fonts/,
	Scale = .9,
	Extension = .ttf,
	Contextuals=Alternate,
	BoldFont={*-Bold},
	UprightFont={*-Regular},
]{Fira Code}

\usepackage[duration=90]{pdfpc}
\newcommand<>{\talknote}[1]{\only#2{\pdfpcnote{- #1}\relax}}

\def\link #1 to #2;{\def\ULdepth{.5pt}\def\ULthickness{.1pt}\uline{\href{#2}{#1}}}

\usetikzlibrary{tikzmark}
\def\m#1{\tikzmark{#1}}
\newcommand<>\ul[5][0pt]{\begin{tikzpicture}[o,blend mode=multiply]
	\coordinate(#5_west) at ([yshift=#1-0.25ex]pic cs:#3);
	\coordinate(#5_east) at ([yshift=#1+0.35ex]pic cs:#4);
	\fill[ul=#2,visible on=#6] (#5_west) rectangle node(#5){} (#5_east);
\end{tikzpicture}}
\tikzset{ul/.style={#1!70!black,opacity=0.40,rounded corners=.17ex}}
\newcounter{ulcntr}\setcounter{ulcntr}{0}
\newcommand<>\doul[2]{%
	\m{uls\theulcntr}#2\m{ule\theulcntr}%
	\ul<#3>{#1}{uls\theulcntr}{ule\theulcntr}{}%
	\stepcounter{ulcntr}%
}

\tikzset{bb/.style={draw=tcbcolframe,dash pattern=on 1mm off 1mm,dash phase=0.5mm,tcb@spec,segmentation@style}}
\def\setlinetext#1{\small\color{tcbcolframe}\contourlength{1.5pt}\contour{tcbcolback}{#1}}
\renewenvironment{block}[1][]{%
	\begin{beamerbox}[segmentation code={
		\path[bb] (segmentation.west) to node{\setlinetext{#1}} (segmentation.east);
	}]{gray}{}%
}{\end{beamerbox}}
\newenvironment{sblock}[1][]{
	\begin{beamerbox}[sidebyside,segmentation code={
		\path[bb] (segmentation.north) to node[rotate=90]{\setlinetext{#1}} (segmentation.south);
	}]{gray}{}%
}{\end{beamerbox}}

\usepackage{emoji}

\usepackage[verbatim]{lstfiracode}
\lstdefinestyle{firastyleb}{style=FiraCodeStyle,style=smile@lst@base}
\lstdefinestyle{firastylep}{style=FiraCodeStyle,style=smile@lst@plain}
\lstset{
	tabsize=4,
	style=firastylep,
	%apptoliterate={{=> }{{{=> }}}3} % for whatever reason, the space would otherwise be eaten
}
\lstdefinelanguage{myhaskell}{
	language=haskell,
	morekeywords={MonadReader,Getting,ASetter,Lens},
}
\newcommand\hn[2][]{\lstinline[language=myhaskell,#1]{#2}}
\def\inlineblock#1{\tikz[anchor=base,baseline]\node[inner sep=0.3333em,rnd,fill=lightgray!50,anchor=base,baseline=] {#1};}
\newcommand\h[2][]{\inlineblock{\hn[#1]{#2}}}
\lstnewenvironment{haskell}{\lstset{language=myhaskell}}{}
\makeatletter
\def\inpuths #1 from #2 to #3;{\lstinputlisting[language=myhaskell,firstline=#2,lastline=#3]{#1}}
\def\inputhsxs #1 from #2 to #3;{\lstinputlisting[language=myhaskell,firstline=#2,lastline=#3,basicstyle=\smile@lst@style@base\footnotesize]{#1}}
\def\inputhsxxs #1 from #2 to #3;{\lstinputlisting[language=myhaskell,firstline=#2,lastline=#3,basicstyle=\smile@lst@style@base\tiny]{#1}}
\makeatother

\background{background.jpg}
\title{Lenses}
\subtitle{Functional Programming II}
\author{Lukas Pietzschmann}
\email{lukas.pietzschmann@uni-ulm.de}
\institute{Institute of Software Engineering and Programming Languages}
\uni{Ulm University}
\location{Ulm}
\date{May 13$^\text{th}$, 2024}

\addtobeamertemplate{title page}{}{
\tikz[o]\node[anchor=south east,outer sep=0pt] at (current page.south east)
{\fontsize{4}{4}\selectfont\color{white}This image was generated by AI (DALLE 3)};
}

\begin{document}
\maketitle

\section{What}

\begingroup
\colorlet{m}{blue!45!black}
\colorlet{accent}{m}
\makeatletter\smile@listings@initcolors\makeatother
\setbeamercolor{footline}{fg=white,bg=m}
\setbeamercolor{footlineright}{fg=white,bg=m}
\def\qn#1{\textcolor{orange!80!black}{\textbf{#1}}}
\begin{frame}[t,fragile]
	\frametitle{What are lenses}
	\tikzset{q/.style={chamfered rectangle,draw,lw,chamfered rectangle xsep=2cm,fill=m,text=white}}
	\tikzset{qa/.style={q,text width=0.4\textwidth}}
	\begin{wide}\vspace{5mm}
		\begin{haskell}
			type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t

			view :: MonadReader s m => Getting a s a -> m a
			set  :: ASetter s t a b -> b -> s -> t
		\end{haskell}
		\begin{tikzpicture}[o,node distance=.5ex]
			\draw[draw=none,top color=white,bottom color=m] (current page.west) rectangle ([yshift=1.8ex]current page.south east);

			\node[q] at ([yshift=-5mm]current page) (Q) {What is the purpose of a lens, according to the types above?};
			\coordinate (AS) at ([yshift=-1.3cm]Q.south);

			\node[qa,left=of AS,left] (A) {\scriptsize\qn{A:} A package for creating visualizations};
			\node[qa,right=of AS,right] (B) {\scriptsize\qn{B:} A tool for handling nested ADTs};

			\node[qa,below=of A] (C) {\scriptsize\qn{C:} A framework for building UIs};
			\node[qa,below=of B] (D) {\scriptsize\qn{D:} A package for simulating optical lenses};

			\draw[lw,short=-1pt] (A.east) to (B.west);
			\draw[lw,short=-1pt] (C.east) to (D.west);

			\draw[lw,short=-1pt] (Q.west) to (Q.west -| current page.west);
			\draw[lw,short=-1pt] (Q.east) to (Q.east -| current page.east);

			\draw[lw,short=-1pt] (A.west) to (A.west -| current page.west);
			\draw[lw,short=-1pt] (C.west) to (C.west -| current page.west);
			\draw[lw,short=-1pt] (B.east) to (B.east -| current page.east);
			\draw[lw,short=-1pt] (D.east) to (D.east -| current page.east);
		\end{tikzpicture}
	\end{wide}
	\begin{modal}<2|handout:2>
		\begin{quote}
			In Haskell, types provide a pretty good explanation of what a function does. Good luck deciphering lens types.
		\end{quote}\par
		\hfill Roman Cheplyaka
	\end{modal}
\end{frame}
\endgroup

\begin{frame}
	\frametitle{What are lenses}
	Well, \enquote{Lenses} is \textit{only} a \link package to https://hackage.haskell.org/package/lens; \ldots{}
	Here are some common function from that package:\bigskip
	\begin{center}
		\begin{tabular}{lcl}
		\hline
		\hn{view} & \hn{_1}  & \hn{forOf}      \\ \hline
		\hn{set}  & \hn{.>}  & \hn{traverseOf} \\ \hline
		\hn{at}   & \hn{^@?} & \hn{over}       \\ \hline
		\end{tabular}
	\end{center}\bigskip
	We'll shortly see what they do and how we can use them.
\end{frame}

\section{Why}

\begin{frame}
	\frametitle{Why do we need them}
	Imagine you want to parse configuration files in Haskell. To model them, you come up
	with the following ADTs:\bigskip
	\inpuths examples/example.hs from 1 to 12;
\end{frame}

\begin{frame}
	\frametitle{Why do we need them}
	Let's say we parsed a file into the following configuration:\bigskip
	\inpuths examples/example.hs from 24 to 28;\bigskip
	Cool, isn't it. Now we want to work with this representation.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Why do we need them}
	\inpuths examples/example.hs from 30 to 41;\medskip
	Oof, this sucks. And it get's even worse the deeper the ADT gets!
	\begin{tikzpicture}[o]
		\node[anchor=west,yshift=8mm] at (current page.west) (A) {
			\inputhsxxs examples/example.hs from 5 to 8;
		};
		\node[anchor=west,yshift=1.2cm] at (current page.west |- A) {
			\inputhsxxs examples/example.hs from 1 to 4;
		};
		\node[anchor=west,yshift=-1.2cm] at (current page.west |- A) {
			\inputhsxxs examples/example.hs from 9 to 12;
		};
	\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	Let's see, if we can improve this by adding some modifier
	functions:\makeatletter\medskip
	\inputhsxs examples/example.hs from 45 to 56;
\end{frame}

\begin{frame}
	\frametitle{Let's reinvent the lens}
	We can use our modify-functions to implement a setter:
	\inpuths examples/example.hs from 58 to 59;\bigskip

	The getter is still fine:
	\inpuths examples/example.hs from 61 to 62;\bigskip
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	Now, we can build our lens abstraction
	\inputhsxs examples/example.hs from 64 to 67;\medskip

	We need to \enquote{reimplement} the function composition:
	\inputhsxs examples/example.hs from 69 to 73;\medskip

	For easier handling, we also define \h{set} as a little helper:
	\inputhsxs examples/example.hs from 75 to 76;
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	Finally, we can build lenses for our ADTs:\makeatletter\medskip
	\inputhsxs examples/example.hs from 78 to 91;
\end{frame}

\begin{frame}
	\frametitle{Let's reinvent the lens}
	Now we only have to plug our lens into \h{set}, \h{get}, or \h{modify}:
	\inpuths examples/example.hs from 93 to 94;
	\inpuths examples/example.hs from 96 to 97;
\end{frame}

\begin{frame}
	\frametitle{Let's reinvent the lens}
	\color{red}\bfseries Play GHC and evaluate an expression step by step
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	Puh, that was kinda complicated. But again, think of how much less code you have to
	write:\par
	\begin{sblock}[versus]
		\begin{haskell}
			let f = _foo v
				b = _bar f
				z = _baz b in
			v { _foo = f {
					_bar = b {
						_baz = z + 1
					} } }
		\end{haskell}
		\tcblower
		\begin{haskell}
			v & foo . bar . baz +~ 1
		\end{haskell}
	\end{sblock}
	We can now think \enquote{How can I traverse through this?} instead of \enquote{How do
	I un- and repack all of this?}.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	Our solution looks more flexible than what we had before. But there are still some
	problems:\bigskip
	\begin{itemize}
		\item Still feels a bit clunky and boilerplate-heavy
		\item We always have to create \h{Lens} values
		\item No support for polymorphic updates
	\end{itemize}\bigskip
	It's definitely not impossible to overcome these limitations, but we'll skip this
	for now.
	\begin{modal}<2|handout:2>[\footnotesize Polymorphic Update]
		\begin{haskell}
			data Pair a b = Pair {e1 :: a, e2 :: b}

			p :: Pair Int String
			p = Pair 420 "is fun"

			p { e1 = "FP" }  §\ergo\texttt{~~~Pair \{ e1 = "FP", e2 = "is fun" \}}§
		\end{haskell}\bigskip
		\ergo{} Notice that the type has changed from \h{Pair Int String} to \h{Pair
		String String}. This is what we call \emph{polymorphic update}.
	\end{modal}
\end{frame}

\begin{frame}
	\frametitle[Revisited]{What are lenses}
	Lenses are:
	\begin{itemize}
		\item A way to \emph{focus} on a part of a data structure
	\end{itemize}\bigskip
	Or more precisely:
	\begin{itemize}
		\item Just another abstraction
		\item Functional references
		\item Getters and Setters
		\item Highly composable  and flexible
			\begin{itemize}
				\item \enquote{The Power is in the Dot}\quad\textcolor{gray}{Edward Kmett}
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle[\cite{lenshist}]{A little history lesson}
	\begin{itemize}[<+(1)->]\setlength\itemsep{.7em}
		% \item[\tikzmark{a}] Jeremy Gibbons and Bruno Oliveira demonstrate that
		% 	Traversals encode the Iterator pattern~\cite{gibbons2009}
		\item[\tikzmark{b}] Luke Palmer creates a pattern he calls \emph{Accessors} to
			ease stateful programming in Haskell~\cite{palmer2007game}. He uses C's
			preprocessor to generate \h{readVal} and \h{writeVal} functions.\footnote{In
			another blog post he then swaps out the preprocessor in favour of Template
			Haskell.}
		\item[\tikzmark{c}] Palmer generalizes his Accessors into something more like
			today's lenses.~\cite{palmer2007acc}
		\item[\tikzmark{d}] Twan van Laarhoven comes up with a novel way to express
			lenses using the \h{Functor} class~\cite{laarhoven2009}. We call them
			\emph{van Laarhoven lenses}.
	\end{itemize}
	\begin{tikzpicture}[remember picture,overlay]
		\coordinate (S) at ([shift={(-2mm,1.5mm)}]pic cs:b);
		\coordinate (E) at ([shift={(-2mm,0cm)}]pic cs:d);
		\draw[lw,visible on=<4->] (S) -- (E);
		\draw[dashed,lw,visible on=<4->] (E) -- ([yshift=-1cm]E);
		\node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<4->] at (S) {};
		% \node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<5->] at ([shift={(-2mm,1.5mm)}]pic cs:b) {};
		\node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<6->] at ([shift={(-2mm,1.5mm)}]pic cs:c) {};
		\node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<7->] at ([shift={(-2mm,1.5mm)}]pic cs:d) {};
	\end{tikzpicture}
\end{frame}

\begin{frame}
	\frametitle[\cite{lenshist}]{A little history lesson}
	\begin{itemize}[<+(1)->]\setlength\itemsep{.7em}
		\item[\tikzmark{e}] Russell O'Connor realises van Laarhoven lenses have always
			supported polymorphic updates.~\cite{connor2012}
		\item[\tikzmark{f}] Edward Kmett realises that you can put laws on the notion of
			polymorphic updates.~\cite{kmett2012}
		\item[\tikzmark{g}] Kmett pushed the \link first commit to
			https://github.com/ekmett/lens/commit/c5c8e5ffeeccdd7ac78f758dfc5723c411443d78;
			to the lens repository on \link GitHub to https://github.com/ekmett/lens;
	\end{itemize}
	\begin{tikzpicture}[remember picture,overlay]
		\coordinate (S) at ([shift={(-2mm,1.5mm)}]pic cs:e);
		\coordinate (E) at ([shift={(-2mm,-1.1cm)}]pic cs:g);
		\draw[dashed,lw,visible on=<4->] ([yshift=7.5mm]S) -- (S);
		\draw[-{Latex[round,accent]},lw,visible on=<4->] (S) -- (E);Turned Square
		\node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<4->] at (S) {};
		\node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<5->] at ([shift={(-2mm,1.5mm)}]pic cs:f) {};
		\node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<5->] at ([shift={(-2mm,1.5mm)}]pic cs:g) {};
	\end{tikzpicture}
\end{frame}

\section{How}
\subsection{A little Overview}

\begin{frame}
	\frametitle{A little Overview}
	Lenses basically provide two kinds of operations:
	\begin{itemize}
		\item \hn{view :: Lens' a b -> a -> b}
		\item \hn{set :: Lens' a b -> b -> a -> a}
	\end{itemize}\medskip
	To use them, we need the actual lens. It determines what part of the structure
	we want to focus on.
	\begin{itemize}
		\item \hn{_1 :: Lens' (a,b) a}
		\item \hn{_2 :: Lens' (a,b) b}
	\end{itemize}\medskip
	With all that in place, we can now combine the operation with a lens (or a
	combination of lenses) and data:
	\begin{itemize}
		\item \doul{red}{\hn{set}} \doul{blue}{\hn{_2}} \doul{green}{\hn{"cool"}} \doul{green}{\hn{("FP is", "")}}\kern8pt\ergo\kern8pt\hn{("FP is", "cool")}
		\item \doul{red}{\hn{view}} \doul{blue}{\hn{_1}} \doul{green}{\hn{("hi", "there")}}\kern8pt\ergo\kern8pt\hn{"hi"}
	\end{itemize}%
\end{frame}

\subsection{Lens Laws}

\begin{frame}
	\frametitle{Lens Laws}
	Like with functors, applicatives, and monads, lenses \emph{should} follow some
	rules:
	\begin{enumerate}
		\item Get-Put
		\item Put-Get
		\item Put-Put
	\end{enumerate}
	We'll look at them in a bit more detail.
\end{frame}

\begin{frame}[fragile]
	\frametitle[Get-Put]{Lens Laws}
	If you modify something by changing its subpart to exactly what it was before,
	nothing should happen.\bigskip
	\begin{haskell}
		set entryCurrentValueL (get entryCurrentValueL entry) entry == entry
	\end{haskell}\bigskip
	\ergo{} Our lens should not modify the value or structure by itself.
\end{frame}

\begin{frame}[fragile]
	\frametitle[Put-Get]{Lens Laws}
	If you modify something by inserting a particular subpart and then view the result,
	you'll get back exactly that subpart.\bigskip
	\begin{haskell}
		get entryCurrentValueL (set entryCurrentValueL "a" entry) == "a"
	\end{haskell}\bigskip
	\ergo{} The Lens should perform the update.
\end{frame}

\begin{frame}[fragile]
	\frametitle[Put-Put]{Lens Laws}
	If you modify something by inserting a particular subpart \h{a}, and then modify it
	again inserting a different subpart \h{b}, it's exactly as if you only did the
	second insertion.\bigskip
	\begin{haskell}
		set entryCurrentValueL "b" (set entryCurrentValueL "a" entry) == set entryCurrentValueL "b" entry
	\end{haskell}\bigskip
	\ergo{} Previous updated should not leave any traces.
\end{frame}

\begin{frame}
	\frametitle{Do I really have to follow them?}
	\begin{itemize}
		\item Yes, you should! Otherwise your lenses might behave weird.
	\end{itemize}\bigskip
	\begin{itemize}
		\item But, we can get around them
		\item In fact, we can get around the whole process of creating a lens by
			hand
		\item You remember Template-Haskell, do you?
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Do I really have to follow them?}
	\inpuths examples/example2.hs from 1 to 11;
\end{frame}

\subsection{The actual Package}

\begin{frame}
	\frametitle{The lens Package}
	\begin{itemize}
		\item Until now, we have only used \h{view} and \h{set}
		\item But there are actually a lot more functions and operators
		\item I mean a loooooooooooooooooot; easily over 100
	\end{itemize}\bigskip
	\begin{itemize}
		\item Let's try to find a pattern in their names
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{The lens Package}
	\begin{wide}
	\begin{columns}[c]
		\begin{column}{0.45\textwidth}
			\begin{block}
			Operators beginning with \h{^} behave like \h{view} functions:
			\begin{haskell}
				Value "c" "d" ^. def §\ergo~\texttt{"d"}§
				Right 42 ^? _Left §\ergo~\texttt{Nothing}§
			\end{haskell}
			\end{block}
		\end{column}
		\begin{column}{0.45\textwidth}
			\begin{block}
				Operators ending in \inlineblock{\string~\rlap{\phantom{t}}} behave like \h{set} functions:
			\begin{haskell}
				(_2 .~ 3) (0, 0) §\ergo~\texttt{(0, 3)}§
				(_2 +~ 3) (0, 39) §\ergo~\texttt{(0, 42)}§
			\end{haskell}
			\end{block}
		\end{column}
	\end{columns}\bigskip
	Writing \h{lens .~ value $ adt} every time is not very nice. But as always, there's
	a special operator to our rescue: \h{& :: a -> (a -> b) -> b}.
	\end{wide}
\end{frame}

\begin{frame}[fragile]
	\frametitle{The lens Package}
	With this knowledge aquired, we can finally write concise haskell-code:\par\medskip
	\begin{haskell}
		(6, 2) & both *~ 7 §\ergo~\texttt{(42, 14)}§
	\end{haskell}\medskip
	\begin{haskell}
		lens = entries . _last . value . curr
		val = config ^?! lens §\ergo~\texttt{"88"} §
		config & lens .~ val ++ "0" §\ergo~\texttt{\{ curr = "880", ... \} ...}§
		over lens (++"0") config §\ergo\texttt{\{ curr = "880", ... \} ...}§
	\end{haskell}\medskip
	\begin{haskell}
		(0, "upd.") & _1 .~ "poly." §\ergo~\texttt{("poly.", "upd.")}§
	\end{haskell}
\end{frame}

% \begin{frame}
% 	\frametitle{The lens Package}
% 	\begin{description}
% 		\item[\h{view}] \h{v ^. l}
% 		\item[\h{set}] \h{v & l .~ x}
% 		\item[\h{set Just}] \h{v & l ?~ mx}
% 		\item[\h{incr}] \h{v & l +~ n}
% 		\item[\h{append}] \h{v & l <>~ x}
% 	\end{description}
% \end{frame}

\tikzset{b/.style={arrow,short=1mm,draw=green}}
\tikzset{c/.style={arrow,short=1mm,draw=lightgray,dashed}}
\begin{frame}
	\frametitle[Gotchas]{The lens Package}
	You might have notices that lenses compose backwards:\par\bigskip
	\begin{center}
	\begin{tikzpicture}[node distance=7mm]
		\node[roundednode] (A) {\strut\hn{entries}};
		\node[roundednode,right=of A] (B) {\strut\hn{_last}};
		\node[roundednode,right=of B] (C) {\strut\hn{value}};
		\node[roundednode,right=of C] (D) {\strut\hn{curr}};
		\node[left=of A] (AA) {};
		\node[right=of D] (DD) {};

		\begin{scope}[transform canvas={yshift=1.2mm}]
			\draw[b] (AA) to (A);
			\draw[b] (A) to (B);
			\draw[b] (B) to (C);
			\draw[b] (C) to (D);
			\draw[b] (D) to (DD);
		\end{scope}

		\begin{scope}[transform canvas={yshift=-1.2mm}]
			\draw[c] (DD) to (D);
			\draw[c] (D) to (C);
			\draw[c] (C) to (B);
			\draw[c] (B) to (A);
			\draw[c] (A) to (AA);
		\end{scope}
	\end{tikzpicture}
	\end{center}\par\medskip
	This makes it weird for FP-enjoyers, but intuitive for OOP-weirdos.\par
	The same applies for all kinds of operators:\par
	\begin{center}
		\begin{tabular}{c|c}
			lens & Haskell\\
			\hline\hline
			\hn{5 & (+1)} & \hn{(+1) $ 5}\\
			\hn{Just 5 <&> (+1)} & \hn{(+1) <$> (Just 5)}\\
		\end{tabular}
	\end{center}
	\begin{modal}<2|handout:2>
		\begin{quote}
			Backward composition of lenses. It’s a minor issue, and I wouldn’t mention
			it if it wasn’t a great demonstration of how lens goes against the
			conventions of Haskell.
		\end{quote}\par
		\hfill Roman Cheplyaka
	\end{modal}
\end{frame}

\section{More goodies}

\subsection{Virtual lenses}
\begin{frame}[fragile]
	\frametitle{Virtual lenses}
	A Getter does not always have to be backed by an actual structure. Theoretically, it
	can return \emph{anything}:
	\begin{lstlisting}[language=ts]
		get someProp(): number {
			return 42
		}
	\end{lstlisting}\bigskip
	We can emulate this behavior with lenses, too:
	\begin{haskell}
		someProp = like 42
		(0, 0) ^. someProp §\ergo~\texttt{42}§
	\end{haskell}
\end{frame}

\subsection{Prisms}

\begin{frame}[fragile]
	\frametitle{Prisms}
	\begin{columns}[c]
		\begin{column}{0.45\textwidth}
			\begin{block}
			Lenses reference something that \emph{always} exists.
			\end{block}
		\end{column}
		\begin{column}{0.45\textwidth}
			\begin{block}
			Prisms reference something that \emph{may} exist.
			\end{block}
		\end{column}
	\end{columns}\bigskip
	\inpuths examples/prism.hs from 5 to 9;
	\begin{haskell}
		meal1 ^? _MainCourse . _2 . _Desert §\ergo~\texttt{Just "Pudding"}§
		meal2 ^? _MainCourse . _2 . _Desert §\ergo~\texttt{Nothing}§
	\end{haskell}
	\begin{haskell}
		meal1 &  _MainCourse . _2 . _Desert .~ "Yogurt"
	\end{haskell}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Prisms}
	\begin{itemize}
		\item Functions that are prefixed by an underscore are prisms
		\item We already used a prism: remember \h{_last}?
		\item We can usually use them like a normal lens (there's just a lillte
			\h{Maybe} in the way)
	\end{itemize}\bigskip
	\begin{block}[versus]
		\begin{haskell}
			case meal1 of
				MainCouse _ (Desert d) -> MainCourse {
					desert = Desert "Yogurt" }
				_ -> meal1
		\end{haskell}
		\tcblower
		\begin{haskell}
			meal1 &  _MainCourse . _2 . _Desert .~ "Yogurt"
		\end{haskell}
	\end{block}
\end{frame}

\subsection{Traversals}
\begin{frame}
	\frametitle{Traversals}
	\begin{columns}[c]
		\begin{column}{0.45\textwidth}
			\begin{block}
			Lenses reference something that \emph{always} exists.
			\end{block}
		\end{column}
		\begin{onlyenv}<1|handout:0>
		\begin{column}{0.45\textwidth}
			\begin{block}
			Prisms reference something that \emph{may} exist.
			\end{block}
		\end{column}
		\end{onlyenv}
		\begin{onlyenv}<2-|handout:1->
		\begin{column}{0.45\textwidth}
			\begin{block}
			Traversals reference \emph{many things} that \emph{may} exist.
			\end{block}
		\end{column}
		\end{onlyenv}
	\end{columns}\bigskip
\end{frame}

\subsection{Isos}
\begin{frame}
	\frametitle{Isos}
\end{frame}

\section{References}
\defbibheading{bibliography}[\bibname]{}

\begin{frame}[allowframebreaks]
	\frametitle{Reading suggestions}
	\printbibliography[keyword={suggestion}]
\end{frame}

\begin{frame}[allowframebreaks]
	\frametitle{References}
	\printbibliography
\end{frame}
\end{document}
