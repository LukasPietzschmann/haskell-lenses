\documentclass[aspectratio=169,handout]{beamer}

\makeatletter
\appto\input@path{{libs/awesome-beamer}, {libs/smile}}
\makeatother

\definecolor{dred}{HTML}{501613}
\usetheme[english, color, coloraccent=dred, secslide, listings, footnote]{awesome}

\usepackage[
	backend=biber,
	style=alphabetic
]{biblatex}
\usepackage[strict,autostyle]{csquotes}
\nocite{*}
\addbibresource{refs.bib}

\usepackage{fontawesome5}
\def\ergo{\raisebox{.5pt}{\scalebox{.8}{\faCaretRight}}}

\usepackage{fontspec}
\setsansfont[
	Ligatures=TeX,
	BoldFont={* Medium},
]{Fira Sans}
\setmonofont[
	Path = ./fonts/,
	Scale = .9,
	Extension = .ttf,
	Contextuals=Alternate,
	BoldFont={*-Bold},
	UprightFont={*-Regular},
]{Fira Code}

\usepackage[duration=90]{pdfpc}
\newcommand<>{\talknote}[1]{\only#2{\pdfpcnote{- #1}\relax}}

\def\link #1 to #2;{\def\ULdepth{.5pt}\def\ULthickness{.1pt}\uline{\href{#2}{#1}}}

\usetikzlibrary{tikzmark}
\def\m#1{\tikzmark{#1}}

\usepackage{emoji}

\usepackage[verbatim]{lstfiracode}
\lstdefinestyle{firastyleb}{style=FiraCodeStyle,style=smile@lst@base}
\lstdefinestyle{firastylep}{style=FiraCodeStyle,style=smile@lst@plain}
\lstset{
	tabsize=4,
	style=firastylep,
	%apptoliterate={{=> }{{{=> }}}3} % for whatever reason, the space would otherwise be eaten
}
\lstdefinelanguage{myhaskell}{
	language=haskell,
	morekeywords={MonadReader,Getting,ASetter,Lens},
}
\newcommand\h[2][]{\lstinline[language=myhaskell,#1]{#2}}
\lstnewenvironment{haskell}{\lstset{language=myhaskell}}{}
\makeatletter
\def\inpuths #1 from #2 to #3;{\lstinputlisting[language=myhaskell,firstline=#2,lastline=#3]{#1}}
\def\inputhsxs #1 from #2 to #3;{\lstinputlisting[language=myhaskell,firstline=#2,lastline=#3,basicstyle=\smile@lst@style@base\footnotesize]{#1}}
\def\inputhsxxs #1 from #2 to #3;{\lstinputlisting[language=myhaskell,firstline=#2,lastline=#3,basicstyle=\smile@lst@style@base\tiny]{#1}}
\makeatother

\background{background.jpg}
\title{Lenses}
\subtitle{Functional Programming II}
\author{Lukas Pietzschmann}
\email{lukas.pietzschmann@uni-ulm.de}
\institute{Institute of Software Engineering and Programming Languages}
\uni{Ulm University}
\location{Ulm}
\date{May 24$^\text{th}$, 2024}

\addtobeamertemplate{title page}{}{
\tikz[o]\node[anchor=south east,outer sep=0pt] at (current page.south east)
{\fontsize{4}{4}\selectfont\color{white}This image was generated by AI (DALLE 3)};
}

\begin{document}
\maketitle

\section{What}

\begingroup
\colorlet{m}{blue!45!black}
\colorlet{accent}{m}
\makeatletter\smile@listings@initcolors\makeatother
\setbeamercolor{footline}{fg=white,bg=m}
\setbeamercolor{footlineright}{fg=white,bg=m}
\def\qn#1{\textcolor{orange!80!black}{\textbf{#1}}}
\begin{frame}[t,fragile]
	\frametitle{What are lenses}
	\tikzset{q/.style={chamfered rectangle,draw,lw,chamfered rectangle xsep=2cm,fill=m,text=white}}
	\tikzset{qa/.style={q,text width=0.4\textwidth}}
	\begin{wide}\vspace{5mm}
		\begin{haskell}
			type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t

			view :: MonadReader s m => Getting a s a -> m a
			set  :: ASetter s t a b -> b -> s -> t
		\end{haskell}
		\begin{tikzpicture}[o,node distance=.5ex]
			\draw[draw=none,top color=white,bottom color=m] (current page.west) rectangle ([yshift=1.8ex]current page.south east);

			\node[q] at ([yshift=-5mm]current page) (Q) {What is the purpose of a lens, according to the types above?};
			\coordinate (AS) at ([yshift=-1.3cm]Q.south);

			\node[qa,left=of AS,left] (A) {\scriptsize\qn{A:} A package for creating visualizations};
			\node[qa,right=of AS,right] (B) {\scriptsize\qn{B:} A tool for handling nested ADTs};

			\node[qa,below=of A] (C) {\scriptsize\qn{C:} A framework for building UIs};
			\node[qa,below=of B] (D) {\scriptsize\qn{D:} A package for simulating optical lenses};

			\draw[lw,short=-1pt] (A.east) to (B.west);
			\draw[lw,short=-1pt] (C.east) to (D.west);

			\draw[lw,short=-1pt] (Q.west) to (Q.west -| current page.west);
			\draw[lw,short=-1pt] (Q.east) to (Q.east -| current page.east);

			\draw[lw,short=-1pt] (A.west) to (A.west -| current page.west);
			\draw[lw,short=-1pt] (C.west) to (C.west -| current page.west);
			\draw[lw,short=-1pt] (B.east) to (B.east -| current page.east);
			\draw[lw,short=-1pt] (D.east) to (D.east -| current page.east);
		\end{tikzpicture}
	\end{wide}
	\begin{modal}<2|handout:2>
		\begin{quote}
			In Haskell, types provide a pretty good explanation of what a function does. Good luck deciphering lens types.
		\end{quote}\par
		\hfill Roman Cheplyaka
	\end{modal}
\end{frame}
\endgroup

\begin{frame}
	\frametitle{What are lenses}
	Well, \enquote{Lenses} is \textit{only} a \link package to https://hackage.haskell.org/package/lens; \ldots{}
	Here are some common function from that package:\bigskip
	\begin{center}
		\begin{tabular}{lcl}
		\hline
		\h{view} & \h{_1}  & \h{forOf}      \\ \hline
		\h{set}  & \h{.>}  & \h{traverseOf} \\ \hline
		\h{at}   & \h{^@?} & \h{over}       \\ \hline
		\end{tabular}
	\end{center}\bigskip
	We'll shortly see what they do and how we can use them.
\end{frame}

\section{Why}

\begin{frame}
	\frametitle{Why do we need them}
	Imagine you want to parse configuration files in Haskell. To model them, you come up
	with the following ADTs:\bigskip
	\inpuths examples/example.hs from 1 to 12;
\end{frame}

\begin{frame}
	\frametitle{Why do we need them}
	Let's say we parsed a file into the following configuration:\bigskip
	\inpuths examples/example.hs from 24 to 28;\bigskip
	Cool, isn't it. Now we want to work with this representation.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Why do we need them}
	\inpuths examples/example.hs from 30 to 41;\medskip
	Oof, this sucks. And it get's even worse the deeper the ADT gets!
	\begin{tikzpicture}[o]
		\node[anchor=west,yshift=8mm] at (current page.west) (A) {
			\inputhsxxs examples/example.hs from 5 to 8;
		};
		\node[anchor=west,yshift=1.2cm] at (current page.west |- A) {
			\inputhsxxs examples/example.hs from 1 to 4;
		};
		\node[anchor=west,yshift=-1.2cm] at (current page.west |- A) {
			\inputhsxxs examples/example.hs from 9 to 12;
		};
	\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	Let's see, if we can improve this by adding some modifier
	functions:\makeatletter\medskip
	\inputhsxs examples/example.hs from 45 to 56;
\end{frame}

\begin{frame}
	\frametitle{Let's reinvent the lens}
	We can use our modify-functions to implement a setter:
	\inpuths examples/example.hs from 58 to 59;\bigskip

	The getter is still fine:
	\inpuths examples/example.hs from 61 to 62;\bigskip
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	Now, we can build our \h{Lens} abstraction
	\inputhsxs examples/example.hs from 64 to 67;\medskip

	We need to \enquote{reimplement} the function composition:
	\inputhsxs examples/example.hs from 69 to 73;\medskip

	For easier handling, we also define \h{set} as a little helper:
	\inputhsxs examples/example.hs from 75 to 76;
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	Finally, we can build lenses for our ADTs:\makeatletter\medskip
	\inputhsxs examples/example.hs from 78 to 91;
\end{frame}

\begin{frame}
	\frametitle{Let's reinvent the lens}
	Now we only have to plug our lens into \h{set}, \h{get}, or \h{modify}:
	\inpuths examples/example.hs from 93 to 94;
	\inpuths examples/example.hs from 96 to 97;
\end{frame}

\begin{frame}
	\frametitle{Let's reinvent the lens}
	\color{red}\bfseries Play GHC and evaluate an expression step by step
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	Puh, that was kinda complicated. But again, imagine you had to write\par\medskip
	\begin{haskell}
		let f = _foo v
			b = _bar f
			z = _baz b in
		v { _foo = f {
				_bar = b {
					_baz = z + 1 } } }
	\end{haskell}\medskip
	instead of \h{v & foo.bar.baz +~ 1}\par\bigskip
	We can now think \enquote{How can traverse through this?} instead of \enquote{How do
	I un- and repack all of this?}.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	This definitely looks more flexible than what we had before. But there are still some
	problems:\bigskip
	\begin{itemize}
		\item Still feels a bit clunky and boilerplate-heavy
		\item We always have to create \h{Lens} values
		\item No support for polymorphic updates
	\end{itemize}\bigskip
	We will later see how they can be solved!
	\begin{modal}<2|handout:2>[\footnotesize Polymorphic Update]
		\begin{haskell}
			data Pair a b = Pair {e1 :: a, e2 :: b}

			p :: Pair Int String
			p = Pair 420 "is fun"

			p { e1 = "FP" }  ยง\ergo\texttt{~~~Pair \{ e1 = "FP", e2 = "is fun" \}}ยง
		\end{haskell}\bigskip
		\ergo{} Notice that the type has changed from \h{Pair Int String} to \h{Pair
		String String}. This is what we call \emph{polymorphic update}.
	\end{modal}
\end{frame}

\begin{frame}
	\frametitle[Revisited]{What are lenses}
	Lenses are:
	\begin{itemize}
		\item A way to \emph{focus} on a part of a data structure
	\end{itemize}\bigskip
	Or more precisely:
	\begin{itemize}
		\item Just another abstraction
		\item Functional references
		\item Getters and Setters
		\item Highly composable  and flexible
			\begin{itemize}
				\item \enquote{The Power is in the Dot}\quad\textcolor{gray}{Edward Kmett}
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle[\cite{lenshist}]{A little history lesson}
	\begin{itemize}[<+(1)->]\setlength\itemsep{.7em}
		% \item[\tikzmark{a}] Jeremy Gibbons and Bruno Oliveira demonstrate that
		% 	Traversals encode the Iterator pattern~\cite{gibbons2009}
		\item[\tikzmark{b}] Luke Palmer creates a pattern he calls \emph{Accessors} to
			ease stateful programming in Haskell~\cite{palmer2007game}. He uses C's
			preprocessor to generate \h{readVal} and \h{writeVal} functions.\footnote{In
			another blog post he then swaps out the preprocessor in favour of Template
			Haskell.}
		\item[\tikzmark{c}] Palmer generalizes his Accessors into something more like
			today's lenses.~\cite{palmer2007acc}
		\item[\tikzmark{d}] Twan van Laarhoven comes up with a novel way to express
			lenses using the \h{Functor} class~\cite{laarhoven2009}. We call them
			\emph{van Laarhoven lenses}.
	\end{itemize}
	\begin{tikzpicture}[remember picture,overlay]
		\coordinate (S) at ([shift={(-2mm,1.5mm)}]pic cs:b);
		\coordinate (E) at ([shift={(-2mm,0cm)}]pic cs:d);
		\draw[lw,visible on=<4->] (S) -- (E);
		\draw[dashed,lw,visible on=<4->] (E) -- ([yshift=-1cm]E);
		\node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<4->] at (S) {};
		% \node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<5->] at ([shift={(-2mm,1.5mm)}]pic cs:b) {};
		\node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<6->] at ([shift={(-2mm,1.5mm)}]pic cs:c) {};
		\node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<7->] at ([shift={(-2mm,1.5mm)}]pic cs:d) {};
	\end{tikzpicture}
\end{frame}

\begin{frame}
	\frametitle[\cite{lenshist}]{A little history lesson}
	\begin{itemize}[<+(1)->]\setlength\itemsep{.7em}
		\item[\tikzmark{e}] Russell O'Connor realises van Laarhoven lenses have always
			supported polymorphic updates.~\cite{connor2012}
		\item[\tikzmark{f}] Edward Kmett realises that you can put laws on the notion of
			polymorphic updates.~\cite{kmett2012}
		\item[\tikzmark{g}] Kmett pushed the \link first commit to
			https://github.com/ekmett/lens/commit/c5c8e5ffeeccdd7ac78f758dfc5723c411443d78;
			to the lens repository on \link GitHub to https://github.com/ekmett/lens;
	\end{itemize}
	\begin{tikzpicture}[remember picture,overlay]
		\coordinate (S) at ([shift={(-2mm,1.5mm)}]pic cs:e);
		\coordinate (E) at ([shift={(-2mm,-1.1cm)}]pic cs:g);
		\draw[dashed,lw,visible on=<4->] ([yshift=7.5mm]S) -- (S);
		\draw[-{Latex[round,accent]},lw,visible on=<4->] (S) -- (E);Turned Square
		\node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<4->] at (S) {};
		\node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<5->] at ([shift={(-2mm,1.5mm)}]pic cs:f) {};
		\node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<5->] at ([shift={(-2mm,1.5mm)}]pic cs:g) {};
	\end{tikzpicture}
\end{frame}

\section{How}
\subsection{A little Overview}

\begin{frame}
	\frametitle{A little Overview}
	Lenses basically let us use two functions:
	\begin{itemize}
		\item \h{view :: Lens' a b -> a -> b}
		\item \h{set :: Lens' a b -> b -> a -> a}
	\end{itemize}\medskip
	To use them, we need the actual \h{Lens}. It determines what part of the ADT we want to focus on.
	\begin{itemize}
		\item \h{_1 :: Lens' (a,b) a}
		\item \h{_2 :: Lens' (a,b) b}
	\end{itemize}\medskip
	With all that in place, we can now combine the lens, an operation and data:
	\begin{itemize}
		\item \h{view _1 ("hi", "there")}\kern8pt\ergo\kern8pt\h{"hi"}
		\item \h{set _2 "cool" ("FP is", "")}\kern8pt\ergo\kern8pt\h{("FP is", "cool")}
	\end{itemize}
\end{frame}

\subsection{Lens Laws}

\begin{frame}
	\frametitle{Lens Laws}
	Like with functors, applicatives, and monads, lenses \emph{should} follow some
	rules:
	\begin{enumerate}
		\item Get-Put
		\item Put-Get
		\item Put-Put
	\end{enumerate}
	We'll look at them in a bit more detail.
\end{frame}

\begin{frame}[fragile]
	\frametitle[Get-Put]{Lens Laws}
	If you modify something by changing its subpart to exactly what it was before,
	nothing should happen.\bigskip
	\begin{haskell}
		set entryCurrentValueL (get entryCurrentValueL entry) entry == entry
	\end{haskell}\bigskip
	\ergo{} Our lens should not modify the value or structure by itself.
\end{frame}

\begin{frame}[fragile]
	\frametitle[Put-Get]{Lens Laws}
	If you modify something by inserting a particular subpart and then view the result,
	you'll get back exactly that subpart.\bigskip
	\begin{haskell}
		get entryCurrentValueL (set entryCurrentValueL "lol" entry) == "lol"
	\end{haskell}\bigskip
	\ergo{} The Lens should perform the update.
\end{frame}

\begin{frame}[fragile]
	\frametitle[Put-Put]{Lens Laws}
	If you modify something by inserting a particular subpart \h{a}, and then modify it
	again inserting a different subpart \h{b}, it's exactly as if you only did the
	second insertion.\bigskip
	\begin{haskell}
		set entryCurrentValueL "1" (set entryCurrentValueL "2" entry) == set entryCurrentValueL "1" entry
	\end{haskell}\bigskip
	\ergo{} Previous updated should not leave any traces.
\end{frame}

\begin{frame}
	\frametitle{Do I really have to follow them?}
	\begin{itemize}
		\item Yes, you should! Otherwise your lenses might behave weird.
	\end{itemize}\medskip
	\begin{itemize}
		\item But, we can get around them
		\item In fact, we can get around the whole process of creating a lens by
			hand~\emoji{star-struck}
		\item You remember Template-Haskell, do you?
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Do I really have to follow them?}
	\inpuths examples/example2.hs from 1 to 11;
\end{frame}

\subsection{The actual Package}

\begin{frame}
	\frametitle{The lens Package}
	\begin{itemize}
		\item Until now, we have only used \h{view} and \h{set}
		\item But there are actually a lot more functions and operators
		\item I mean a loooooooooooooooooot, easily over 100
		\item Let's try to find a pattern in their names and write some nice short code
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{The lens Package}
	\begin{wide}
	\begin{columns}[c]
		\begin{column}{0.45\textwidth}
			Operators beginning with \h{^}
			\begin{haskell}
				Value "c" "d" ^. def ยง\ergo~\texttt{"d"}ยง
				Right 42 ^? _Left ยง\ergo~\texttt{Nothing}ยง
			\end{haskell}
			are like \h{view}.
		\end{column}
		\begin{column}{0.45\textwidth}
			Operators ending in \texttt{\~}
			\begin{haskell}
				(_2 .~ 3) (0, 0) ยง\ergo~\texttt{(0, 3)}ยง
				(_2 +~ 3) (0, 39) ยง\ergo~\texttt{(0, 42)}ยง
			\end{haskell}
			are like \h{set}.
		\end{column}
	\end{columns}\bigskip
	Writing \h{lens .~ value & adt} every time is not very nice. But as always, there's
		a special operator to our rescue: \h{& :: a -> (a -> b) -> b}.
	\end{wide}
\end{frame}

\begin{frame}[fragile]
	\frametitle{The lens Package}
	With this knowledge aquired, we can finally write concise haskell-code:
	\begin{haskell}
		(6, 2) & both *~ 7 ยง\ergo~\texttt{(42, 14)}ยง
	\end{haskell}\medskip
	\begin{haskell}
		l = entries . _last . value .curr
		v = config ^?! l ยง\ergo~\texttt{"88"}ยง
		config & l .~ v ++ "0" ยง\ergo~\texttt{"880"}ยง
		over l (++"0") config ยง\ergo~\texttt{"880"}ยง
	\end{haskell}\medskip
	\begin{haskell}
		(0, "upd.") & _1 .~ "poly." ยง\ergo~\texttt{("poly.", "upd.")}ยง
	\end{haskell}
\end{frame}

% \begin{frame}
% 	\frametitle{The lens Package}
% 	\begin{description}
% 		\item[\h{view}] \h{v ^. l}
% 		\item[\h{set}] \h{v & l .~ x}
% 		\item[\h{set Just}] \h{v & l ?~ mx}
% 		\item[\h{incr}] \h{v & l +~ n}
% 		\item[\h{append}] \h{v & l <>~ x}
% 	\end{description}
% \end{frame}

\tikzset{b/.style={arrow,short=1mm,draw=green}}
\tikzset{c/.style={arrow,short=1mm,draw=gray,dashed}}
\begin{frame}
	\frametitle[Gotchas]{The lens Package}
	You might have notices, that lenses compose backwards:\par\bigskip
	\begin{center}
	\begin{tikzpicture}[node distance=7mm]
		\node[roundednode] (A) {\strut\h{entries}};
		\node[roundednode,right=of A] (B) {\strut\h{_last}};
		\node[roundednode,right=of B] (C) {\strut\h{value}};
		\node[roundednode,right=of C] (D) {\strut\h{curr}};

		\draw[b] (A) to (B);
		\draw[b] (B) to (C);
		\draw[b] (C) to (D);

		\draw[c] (D.south) to[bend left] (C.south);
		\draw[c] (C.south) to[bend left] (B.south);
		\draw[c] (B.south) to[bend left] (A.south);
	\end{tikzpicture}
	\end{center}\par\medskip
	This makes it weird for FP-enjoyers, but intuitive for OOP-weirdos.\par
	The same applies for all kinds of operators:\par
	\begin{center}
		\begin{tabular}{c|c}
			lens & Haskell\\
			\hline\hline
			\h{5 & (+1)} & \h{(+1) $ 5}\\
			\h{Just 5 <&> (+1)} & \h{(+1) <$> (Just 5)}\\
		\end{tabular}
	\end{center}
	\begin{modal}<2|handout:2>
		\begin{quote}
			Backward composition of lenses. Itโs a minor issue, and I wouldnโt mention
			it if it wasnโt a great demonstration of how lens goes against the
			conventions of Haskell.
		\end{quote}\par
		\hfill Roman Cheplyaka
	\end{modal}
\end{frame}

\section{More goodies}
\subsection{Prisms}

\begin{frame}[fragile]
	\frametitle{Prisms}
	\begin{columns}[c]
		\begin{column}{0.45\textwidth}
			Lenses reference something that \emph{always} exists.
		\end{column}
		\begin{column}{0.45\textwidth}
			Prisms reference something that \emph{may} exist.
		\end{column}
	\end{columns}\bigskip
	\inpuths examples/prism.hs from 5 to 9;
	\begin{haskell}
		meal1 ^? _MainCourse . _2 . _Desert ยง\ergo~\texttt{Just "Pudding"}ยง
		meal2 ^? _MainCourse . _2 . _Desert ยง\ergo~\texttt{Nothing}ยง
	\end{haskell}
	\begin{haskell}
		meal1 &  _MainCourse . _2 . _Desert .~ "Yogurt"
	\end{haskell}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Prisms}
	\begin{itemize}
		\item We already used a prism: remember \h{_last}?
		\item Functions that are prefixed by an underscore are prisms
		\item We can usually use them just like lenses (there's just a lillte \h{Maybe} in the way)
	\end{itemize}\bigskip
	Imagine writing
	\begin{haskell}
		case v of
			MainCouse _ (Desert d) -> MainCourse {
				desert = Desert "Yogurt" }
			_ -> v
	\end{haskell}\medskip
	instead of \h{meal1 &  _MainCourse . _2 . _Desert .~ "Yogurt"}
\end{frame}

\subsection{Traversals}
\begin{frame}
	\frametitle{Traversals}
	\begin{columns}[c]
		\begin{column}{0.45\textwidth}
			Lenses reference something that \emph{always} exists.
		\end{column}
		\begin{onlyenv}<1|handout:0>
		\begin{column}{0.45\textwidth}
			Prisms reference something that \emph{may} exist.
		\end{column}
		\end{onlyenv}
		\begin{onlyenv}<2-|handout:1->
		\begin{column}{0.45\textwidth}
			Traversals reference \emph{many things} that \emph{may} exist.
		\end{column}
		\end{onlyenv}
	\end{columns}\bigskip
\end{frame}

\subsection{Isos}
\begin{frame}
	\frametitle{Isos}
\end{frame}

\section{References}
\defbibheading{bibliography}[\bibname]{}

\begin{frame}[allowframebreaks]
	\frametitle{Reading suggestions}
	\printbibliography[keyword={suggestion}]
\end{frame}

\begin{frame}[allowframebreaks]
	\frametitle{References}
	\printbibliography
\end{frame}
\end{document}
