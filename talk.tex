\documentclass[aspectratio=169,handout]{beamer}

\makeatletter
\appto\input@path{{libs/awesome-beamer}, {libs/smile}}
\makeatother

\definecolor{dred}{HTML}{501613}
\usetheme[english, color, coloraccent=dred, listings]{awesome}

\usepackage[
	backend=biber,
	style=alphabetic
]{biblatex}
\usepackage[strict,autostyle]{csquotes}
\nocite{*}
\addbibresource{refs.bib}

\usepackage{fontawesome5}
\def\ergo{\raisebox{.5pt}{\scalebox{.8}{\faCaretRight}}}

\usepackage{fontspec}
\setsansfont[
	Ligatures=TeX,
	BoldFont={* Medium},
]{Fira Sans}
\setmonofont[
	Path = ./fonts/,
	Scale = .9,
	Extension = .ttf,
	Contextuals=Alternate,
	BoldFont={*-Bold},
	UprightFont={*-Regular},
]{Fira Code}

\usepackage[duration=90]{pdfpc}
\newcommand<>{\talknote}[1]{\only#2{\pdfpcnote{- #1}\relax}}

\def\link #1 to #2;{\def\ULdepth{.5pt}\def\ULthickness{.1pt}\uline{\href{#2}{#1}}}

\usepackage[verbatim]{lstfiracode}
\lstdefinestyle{firastyleb}{style=FiraCodeStyle,style=smile@lst@base}
\lstdefinestyle{firastylep}{style=FiraCodeStyle,style=smile@lst@plain}
\lstset{
	tabsize=4,
	style=firastylep,
	%apptoliterate={{=> }{{{=> }}}3} % for whatever reason, the space would otherwise be eaten
}
\lstdefinelanguage{myhaskell}{
	language=haskell,
	morekeywords={MonadReader,Getting,ASetter,Lens},
}
\newcommand\h[2][]{\lstinline[language=myhaskell,#1]{#2}}
\lstnewenvironment{haskell}{\lstset{language=myhaskell}}{}
\def\inpuths #1 from #2 to #3;{\lstinputlisting[language=myhaskell,firstline=#2,lastline=#3]{#1}}

\background{background.jpg}
\title{Lenses}
\subtitle{Functional Programming II}
\author{Lukas Pietzschmann}
\email{lukas.pietzschmann@uni-ulm.de}
\institute{Institute of Software Engineering and Programming Languages}
\uni{Ulm University}
\location{Ulm}
\date{May 13$^\text{th}$, 2024}

\addtobeamertemplate{title page}{}{
\tikz[o]\node[anchor=south east,outer sep=0pt] at (current page.south east)
{\fontsize{4}{4}\selectfont\color{white}This image was generated by AI (DALLE 3)};
}

\begin{document}
\maketitle

\section{What}

\begingroup
\colorlet{m}{blue!45!black}
\colorlet{accent}{m}
\makeatletter\smile@listings@initcolors\makeatother
\setbeamercolor{footline}{fg=white,bg=m}
\setbeamercolor{footlineright}{fg=white,bg=m}
\def\qn#1{\textcolor{orange!80!black}{\textbf{#1}}}
\begin{frame}[t,fragile]
	\frametitle{What are lenses}
	\tikzset{q/.style={chamfered rectangle,draw,lw,chamfered rectangle xsep=2cm,fill=m,text=white}}
	\tikzset{qa/.style={q,text width=0.4\textwidth}}
	\begin{wide}\vspace{5mm}
		\begin{haskell}
			type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t

			view :: MonadReader s m => Getting a s a -> m a
			set  :: ASetter s t a b -> b -> s -> t
		\end{haskell}
		\begin{tikzpicture}[o,node distance=.5ex]
			\draw[draw=none,top color=white,bottom color=m] (current page.west) rectangle ([yshift=1.8ex]current page.south east);

			\node[q] at ([yshift=-5mm]current page) (Q) {What is the purpose of a lens, according to the types above?};
			\coordinate (AS) at ([yshift=-1.3cm]Q.south);

			\node[qa,left=of AS,left] (A) {\scriptsize\qn{A:} A package for creating visualizations};
			\node[qa,right=of AS,right] (B) {\scriptsize\qn{B:} A tool for handling nested ADTs};

			\node[qa,below=of A] (C) {\scriptsize\qn{C:} A framework for building UIs};
			\node[qa,below=of B] (D) {\scriptsize\qn{D:} A package for simulating optical lenses};

			\draw[lw,short=-1pt] (A.east) to (B.west);
			\draw[lw,short=-1pt] (C.east) to (D.west);

			\draw[lw,short=-1pt] (Q.west) to (Q.west -| current page.west);
			\draw[lw,short=-1pt] (Q.east) to (Q.east -| current page.east);

			\draw[lw,short=-1pt] (A.west) to (A.west -| current page.west);
			\draw[lw,short=-1pt] (C.west) to (C.west -| current page.west);
			\draw[lw,short=-1pt] (B.east) to (B.east -| current page.east);
			\draw[lw,short=-1pt] (D.east) to (D.east -| current page.east);
		\end{tikzpicture}
	\end{wide}
	\begin{onlyenv}<2|handout:2>
		\begin{tikzpicture}[o,node distance=0pt]
			\filldraw[gray,opacity=0.8] (current page.south west) rectangle (current page.north east);
			\node[draw=black,rnd,fill=white,lw,inner sep=3mm,text width=0.66\paperwidth] at (current page) (T) {
				\begin{quote}
					In Haskell, types provide a pretty good explanation of what a function does. Good luck deciphering lens types.
				\end{quote}\par
				\hfill Roman Cheplyaka
			};
			\node[below=of T] {\tiny\url{https://ro-che.info/articles/2014-04-24-lens-unidiomatic.html}};
		\end{tikzpicture}
	\end{onlyenv}
\end{frame}
\endgroup

\begin{frame}
	\frametitle{What are lenses}
	Well, \enquote{Lenses} is \textit{only} a \link package to https://hackage.haskell.org/package/lens; \ldots{}
	Here are some common function from that package:\bigskip
	\begin{center}
		\begin{tabular}{lcl}
		\hline
		\h{view} & \h{_1}  & \h{forOf}      \\ \hline
		\h{set}  & \h{.>}  & \h{traverseOf} \\ \hline
		\h{at}   & \h{^@?} & \h{over}       \\ \hline
		\end{tabular}
	\end{center}\bigskip
	We'll shortly see what they do and how we can use them.
\end{frame}

\section{Why}

\begin{frame}
	\frametitle{Why do we need them}
	Imagine you want to parse configuration files in Haskell. To model them, you come up
	with the following ADTs:\bigskip
	\inpuths examples/example.hs from 1 to 12;
\end{frame}

\begin{frame}
	\frametitle{Why do we need them}
	Let's say we parsed a file into the following configuration:\bigskip
	\inpuths examples/example.hs from 24 to 28;\bigskip
	Cool, isn't it. Now we want to work with this representation.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Why do we need them}
	\inpuths examples/example.hs from 30 to 41;\medskip
	Oof, this sucks. And it get's even worse the deeper the ADT gets!
	\begin{tikzpicture}[o]
		\node[anchor=west,yshift=8mm] at (current page.west) (A) {
			\lstinputlisting[language=myhaskell,firstline=5,lastline=8,basicstyle=\smile@lst@style@base\tiny]{examples/example.hs}
		};
		\node[anchor=west,yshift=1.2cm] at (current page.west |- A) {
			\lstinputlisting[language=myhaskell,firstline=1,lastline=4,basicstyle=\smile@lst@style@base\tiny]{examples/example.hs}
		};
		\node[anchor=west,yshift=-1.2cm] at (current page.west |- A) {
			\lstinputlisting[language=myhaskell,firstline=9,lastline=12,basicstyle=\smile@lst@style@base\tiny]{examples/example.hs}
		};
	\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	Let's see, if we can improve this by adding some modifier
	functions:\makeatletter\medskip
	\lstinputlisting[language=myhaskell,firstline=45,lastline=58,basicstyle=\smile@lst@style@base\footnotesize]{examples/example.hs}
\end{frame}

\begin{frame}
	\frametitle{Let's reinvent the lens}
	Now, we can build our \h{Lens} abstraction
	\inpuths examples/example.hs from 60 to 63;\bigskip

	We need to \enquote{reimplement} the function composition:
	\inpuths examples/example.hs from 65 to 69;
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	Finally, we can build lenses for our ADTs:\makeatletter\medskip
	\lstinputlisting[language=myhaskell,firstline=71,lastline=86,basicstyle=\smile@lst@style@base\footnotesize]{examples/example.hs}
\end{frame}

\begin{frame}
	\frametitle{Let's reinvent the lens}
	This definitely looks more flexible than what we had before. But there are still some
	problems that want to be solved:\bigskip
	\begin{itemize}
		\item Still feels a bit clunky and boilerplate-heavy
		\item We always have to create \h{Lens} values
		\item No support for polymorphic updates
	\end{itemize}
\end{frame}

\section{How}

\begin{frame}
	\frametitle{Lens Laws}
	Like with functors, applicatives, and monads, lenses \emph{should} follow some
	rules:
	\begin{enumerate}
		\item Get-Put
		\item Put-Get
		\item Put-Put
	\end{enumerate}
	We'll look at them in a bit more detail.
\end{frame}

\begin{frame}[fragile]
	\frametitle[Get-Put]{Lens Laws}
	If you modify something by changing its subpart to exactly what it was before
	\ldots{} then nothing happens.\bigskip
	\begin{haskell}
		set entryCurrentValueL (mget entryCurrentValueL entry) entry == entry
	\end{haskell}\bigskip
	\ergo{} Our \h{Lens} should not modify the value or structure by itself.
\end{frame}

\begin{frame}[fragile]
	\frametitle[Put-Get]{Lens Laws}
	If you modify something by inserting a particular subpart and then viewing the
	result \ldots{} you'll get back exactly that subpart.\bigskip
	\begin{haskell}
		get entryCurrentValueL (set entryCurrentValueL "lol" entry) == "lol"
	\end{haskell}\bigskip
	\ergo{} The \h{Lens} should perform the update.
\end{frame}

\begin{frame}[fragile]
	\frametitle[Put-Put]{Lens Laws}
	If you modify something by inserting a particular subpart \h{a}, and then modify it
	again inserting a different subpart \h{b} \ldots{} it's exactly as if you only did
	the second step.\bigskip
	\begin{haskell}
		set entryCurrentValueL "1" (set entryCurrentValueL "2" entry) == set entryCurrentValueL "1" entry
	\end{haskell}\bigskip
	\ergo{} Previous updated should not leave any traces.
\end{frame}

\section{References}
\defbibheading{bibliography}[\bibname]{}
\begin{frame}[allowframebreaks]
	\frametitle{References}
	\printbibliography
\end{frame}
\end{document}
